{"meta":{"title":"chenMiao","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"web worker","slug":"04-webWorker","date":"2018-01-30T12:26:22.915Z","updated":"2018-01-30T12:43:01.299Z","comments":true,"path":"2018/01/30/04-webWorker/","link":"","permalink":"http://yoursite.com/2018/01/30/04-webWorker/","excerpt":"","text":"JavaScript 运行机制 Quick Start为什么JavaScript是单线程？1234567JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。 More info — task queue 任务队列12345678910单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入\"任务队列\"（task queue）的任务，只有\"任务队列\"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。） 1234567( 1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。（4）主线程不断重复上面的第三步。 只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复。 More info: — copy - mutablCopy 事件和回调函数1234567 \"任务队列\"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在\"任务队列\"中添加一个事件，表示相关的异步任务可以进入\"执行栈\"了。主线程读取\"任务队列\"，就是读取里面有哪些事件。\"任务队列\"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入\"任务队列\"，等待主线程读取。所谓\"回调函数\"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。\"任务队列\"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，\"任务队列\"上第一位的事件就自动进入主线程。但是，由于存在后文提到的\"定时器\"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 More info: custom Event Loop12345自定义对象如果要浅拷贝就遵守&lt;NSCopying&gt;协议 (copy) 自定义对象如果要深拷贝就遵守&lt;NSMutableCopying&gt;协议 (mutableCopy) 自定义对象遵守了相关协议,就能够调用相应的深拷贝或者浅拷贝的方法 More info: block - copy ? Block定义成属性为什么用Copy?1234MRC : Block的本质是函数指针,内存地址在栈区,使用Copy是为了把Block由栈区拷贝到堆区,共享给当前对象使用. ARC : Block定义成属性时,使用strong和copy的效果是一样,但是苹果官方建议使用copy. More info: memory management 容器的内存管理12345 [tmpM addObject:obj]; 这样obj的引用计数会增加1.tmpM对obj强引用.[tmpM removeObjectAtIndex:0]; obj的引用计数会减1.tmpM不再对obj有引用.","categories":[],"tags":[]},{"title":"objective-C copy","slug":"03-copy","date":"2018-01-30T12:20:42.362Z","updated":"2018-01-30T12:25:50.882Z","comments":true,"path":"2018/01/30/03-copy/","link":"","permalink":"http://yoursite.com/2018/01/30/03-copy/","excerpt":"","text":"copy 就是浅拷贝，mutableCopy就是深拷贝？ Quick Startcopy与retain的区别：123copy是创建一个新对象,retain是创建一个指针,引用对象计数加1.Copy属性表示两个对象内容相同,新的对象retain为1,与旧有对象的引用计数无关,旧有对象没有变化,copy减少对象对上下文的依赖.retain属性表示两个对象地址相同(建立一个指针,指针拷贝),内容当然相同,这个对象的retain值+1也就是说,retain 是指针拷贝,copy 是内容拷贝. More info — NSString - Copy? 字符串为什么要用Copy?123456概念 假如有一个NSMutableString,现在用他给一个retain修饰的NSString赋值,那么只是将NSString指向了NSMutableString所指向的位置,并对NSMUtbaleString计数器加一,此时,如果对NSMutableString进行修改,也会导致NSString的值修改,原则上这是不允许的. 如果是copy修饰的NSString对象,在用NSMutableString给他赋值时,会进行深拷贝,及把内容也给拷贝了一份,两者指向不同的位置,即使改变了NSMutableString的值,NSString的值也不会改变.所以用copy是为了安全,防止NSMutableString赋值给NSString时,前者修改引起后者值变化而用的. 提示 : 谨记Copy属性的setter方法的结构. 简述,当给一个对象赋新值时,会把新值拷贝一个副本出来赋值给对象,这样新值跟旧值就没有任何关系. More info: — copy - mutablCopy 浅拷贝和深拷贝1234567深拷贝 : 内容拷贝,源对象和副本对象指的是两个不同的对象,源对象引用计数器不变,副本对象引用计数器为1. 浅拷贝 : 指针拷贝,源对象和副本对象指的都是同一个对象,对象引用计数器+1,相当于retain 提示 : 只有不可变对象创建不可变副本(copy)才是浅拷贝，其它的都是深拷贝. 如果对不可变对象拷贝,copy是指针拷贝(浅拷贝);但是,mutableCopy就是对象拷贝(深拷贝).如果是对可变对象拷贝,copy都是深拷贝;但是,copy返回的对象是不可变的. More info: custom 自定义对象的拷贝12345自定义对象如果要浅拷贝就遵守&lt;NSCopying&gt;协议 (copy) 自定义对象如果要深拷贝就遵守&lt;NSMutableCopying&gt;协议 (mutableCopy) 自定义对象遵守了相关协议,就能够调用相应的深拷贝或者浅拷贝的方法 More info: block - copy ? Block定义成属性为什么用Copy?1234MRC : Block的本质是函数指针,内存地址在栈区,使用Copy是为了把Block由栈区拷贝到堆区,共享给当前对象使用. ARC : Block定义成属性时,使用strong和copy的效果是一样,但是苹果官方建议使用copy. More info: memory management 容器的内存管理12345 [tmpM addObject:obj]; 这样obj的引用计数会增加1.tmpM对obj强引用.[tmpM removeObjectAtIndex:0]; obj的引用计数会减1.tmpM不再对obj有引用.","categories":[],"tags":[]},{"title":"覚えてるよ","slug":"02-one-nation","date":"2018-01-30T12:20:42.359Z","updated":"2018-01-28T16:24:31.108Z","comments":true,"path":"2018/01/30/02-one-nation/","link":"","permalink":"http://yoursite.com/2018/01/30/02-one-nation/","excerpt":"","text":"私はこの世界を人に鳥は足がないのは、それだけがずっと飛んで飛んで飛んで疲れたよね、風の中で寝ている、この鳥は一生に一度しかない、それはそれは死亡したとき。 Quick StartCreate a new post1$ hexo new \"My New Post sssss\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-01-30T09:24:17.041Z","updated":"2018-01-30T09:24:17.041Z","comments":true,"path":"2018/01/30/hello-world/","link":"","permalink":"http://yoursite.com/2018/01/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}